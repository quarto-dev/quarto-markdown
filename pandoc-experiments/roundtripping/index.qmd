---
title: Pandoc roundtripping
---

Can we define a useful one-to-one mapping between Pandoc AST nodes and text documents read with `pandoc -f markdown`?

The first direct answer is clearly no, because two markdown inputs can produce the same AST:

```
$ pandoc -f markdown -t native
Hello    world.
^D
[ Para [ Str "Hello" , Space , Str "world." ] ]
$ pandoc -f markdown -t native
Hello world.
^D
[ Para [ Str "Hello" , Space , Str "world." ] ]
```

But *some* text inputs _are_ preserved under a Markdown -> Native -> Markdown roundtrip.
In the above example, the string "Hello world." is preserved by the roundtripping transformation:

```
$ echo "Hello world." > input
$ echo "Hello   world." > input2
$ cat input | pandoc -f markdown -t native | pandoc -f native -t markdown | diff /dev/stdin input
$ cat input2 | pandoc -f markdown -t native | pandoc -f native -t markdown | diff /dev/stdin input2
1c1
< Hello world.
---
> Hello   world.
```

## Preliminaries

::: {#def-document}

### Document

A document is any sequence of Unicode code points.

:::


### Canonical Documents

::: {#def-pandoc-roundtrip}

### `pandoc` roundtrip

A _`pandoc` roundtrip from X through Y_ is the process of piping a document through two Pandoc calls: `pandoc -f X -t Y | pandoc -f Y -t X`.

:::

::: {#def-canonical-document}

### Canonical document

A document is considered _canonical_ (to a given format X) if it is equal to the result of its Pandoc roundtrip from X through `native`.

:::

### ASTs

::: {#def-ast}

### AST

An "AST" is an instance of the `Pandoc` datatype from [`pandoc-types`](https://hackage.haskell.org/package/pandoc-types).

:::

In practice we will also say that anything that is clearly isomorphic to a `Pandoc` value "is" an AST as well.
This is so that we can e.g. talk about the output of `pandoc -t native` as an AST.

Similarly to documents, it is not the case that all possible Pandoc ASTs survive a roundtrip (through some other format, often `markdown`).
So we can have an analogous definition:

::: {#def-canonical-ast}

### Canonical AST

An AST is considered _canonical_ (relative to a given format X) if it is equal to the result of its Pandoc roundtrip from `native` through X.

:::

::: callout-note

There is a small but important difference in the two definitions above:

- canonical ASTs are defined relative to the intermediate format
- canonical documents are defined relative to the source format

:::

## Goals/Context

### Robustness of Quarto's Visual Editor

Quarto's visual editor transforms markdown documents into its own internal AST nodes much like `pandoc` converts of markdown documents to `native`.
But because Quarto explicitly produces its documents through calling `pandoc`, we want
the visual editor to not lose any information that is preserved under this Pandoc canonicalization process.

As a result, the extent to which we can characterize canonical `markdown` documents without resorting to invoking `pandoc` will determine the extent to which we can check the quality of the visual editor
roundtripping process.

### Safe replacement of `pandoc`'s `markdown` reader

There are two significant shortcomings of `pandoc`'s `markdown` reader:

- **code blocks**: Pandoc 3 has changed the syntax of code blocks in its markdown reader.
  Pandoc 3 specifically does not support the executable code block syntax that knitr and RMarkdown have historically used.
  As a result, Quarto currently needs to preprocess input documents, and this is both slow and brittle.
- **syntax errors**: neither `-f markdown` nor `-f commonmark` have a notion of syntax errors.
  Empirically, we have observed Quarto users to make mistakes in their documents, we believe that computers out to help users catch mistakes, and we believe syntax errors are the right way to achieve that goal.
  This means that Quarto eventually needs to move from using `pandoc`'s `commonmark` or `markdown` readers.

We intend to replace the front-end syntax of Quarto with our own parser based on tree-sitter grammars.
We also intend this parser to not accept some documents, so Quarto can emit syntax errors (these are "invalid" documents).
The parser implementation will be integrated with Quarto by emitting (Pandoc) ASTs for valid documents.

If we understand the behavior of canonical `markdown` documents, then we can study and validate our external parser integration by observing the intersection of canonical `markdown` documents with the set of valid documents.
Importantly, this intersection is a set of text documents that both parse correctly and the parser behaves as if `pandoc` itself had parsed the document to begin with.

Our design assumes that this parser will be successful if

1) the parser catches large classes of user mistakes
2) the intersection is large enough to contain "a version of every useful document a user could want to write"

The phrase "a version of every useful document a user could want to write" is important enough to explain.
It might be the case that, by virtue of introducing syntax errors, we will make some documents more awkward to write.

#### A worked example of a mistake

Consider this example:

```
Hello, [Quarto(https://quarto.org).
```

It's overwhelmingly likely that a user who wrote this document made a mistake, and instead wanted to write

```
Hello, [Quarto](https://quarto.org).
```

The first document's representation in AST is

```
[ Para
    [ Str "Hello,"
    , Space
    , Str "[Quarto(https://quarto.org)."
    ]
]
```

And if that document is rendered with Pandoc to `html`, this is the result:

```html
<p>Hello, [Quarto(https://quarto.org).</p>
```

This kind of mistake should ideally be caught by our replacement front-end parser, such that this document isn't valid.
But what if the user actually wanted to create precisely this incorrect output?
We would like to be able to allow that.
One existing solution is to use raw HTML blocks:

```
Hello, `[Quarto(https://quarto.org).`{=html}
```

This document has a _different_ AST:

```
[ Para
    [ Str "Hello,"
    , Space
    , RawInline (Format "html") "[Quarto(https://quarto.org)."
    ]
]
```

This new document would be valid under our front-end parser, and the `html` output that `pandoc` generates is identical to the one of the invalid document.

Of course, this only solves the problem for `html` output. 
In addition, raw blocks are of limited applicability in canonicality considerations:

::: {#rem-canonical-raw-loss}

## Canonical ASTs cannot contain RawBlock or RawInline nodes

A canonical ASTs (relative to `markdown`) will not contain any `RawBlock` or `RawInline` nodes.

:::

::: {.proof}

Technically, `pandoc` writers can do anything they want with nodes, and so any proofs here need
to inspect the `pandoc` writers for all formats of interest.

But the idea is that the goal of `RawBlock` and `RawInline` nodes is to produce "naked" output without any additional markup, and so the markup that defined the node as a `RawBlock` or `RawInline` will be missing on output,
and so roundtripping will fail, and so the AST cannot be canonical.

Finally, `pandoc` writers ignore `RawBlock` and `RawInline` nodes of formats that are not their own, immediately failing
the case where the `format` field of these nodes doesn't match the format relatively to which we're making the statement.

:::

For example, note how the raw block disappears in this roundtrip:

````
$ pandoc -f markdown -t native | pandoc -f native -t markdown
```{=markdown}
hello.
```

More.
^D
hello.

More.
````